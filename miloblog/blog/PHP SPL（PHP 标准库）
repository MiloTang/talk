  
	<pre style="background-color:#fdf6e3;color:#586e75;font-family:'Source Code Pro';font-size:13.5pt;">SPL<span style="font-family:'Courier New';">，</span>PHP <span style="font-family:'Courier New';">标准库（</span>Standard PHP Library<span style="font-family:'Courier New';">） ，从 </span>PHP 5.0 <span style="font-family:'Courier New';">起内置的组件和接口，且从 </span>PHP5.3 <span style="font-family:'Courier New';">已逐渐的成熟。</span>SPL <span style="font-family:'Courier New';">在所有的 </span>PHP5 <span style="font-family:'Courier New';">开发环境中被内置，同时无需任何设置。<br></span><span style="font-family:'Courier New';">如何使用？<br></span>SPL<span style="font-family:'Courier New';">提供了一组标准数据结构：双向链表<br></span>SplDoublyLinkedList<br>    SplStack<br>    SplQueue<br><span style="font-family:'Courier New';">双链表是一种重要的线性存储结构，对于双链表中的每个节点，不仅仅存储自己的信息，还要保存前驱和后继节点的地址。<br></span>PHP SPL<span style="font-family:'Courier New';">中的</span>SplDoublyLinkedList<span style="font-family:'Courier New';">类提供了对双链表的操作。<br></span>SplDoublyLinkedList<span style="font-family:'Courier New';">类摘要如下：<br></span><span style="font-family:'Courier New';"><br></span>SplDoublyLinkedList implements Iterator  , ArrayAccess  , Countable  {<br><br>public __construct ( void )<br>public void add ( mixed $index , mixed $newval )<br>//<span style="font-family:'Courier New';">双链表的头部节点<br></span>public mixed top ( void )<br>//<span style="font-family:'Courier New';">双链表的尾部节点<br></span>public mixed bottom ( void )<br>//<span style="font-family:'Courier New';">双联表元素的个数<br></span>public int count ( void )<br>//<span style="font-family:'Courier New';">检测双链表是否为空<br></span>public bool isEmpty ( void )<br><br><br>//<span style="font-family:'Courier New';">当前节点索引<br></span>public mixed key ( void )<br>//<span style="font-family:'Courier New';">移到上条记录<br></span>public void prev ( void )<br>//<span style="font-family:'Courier New';">移到下条记录<br></span>public void next ( void )<br>//<span style="font-family:'Courier New';">当前记录<br></span>public mixed current ( void )<br>//<span style="font-family:'Courier New';">将指针指向迭代开始处<br></span>public void rewind ( void )<br>//<span style="font-family:'Courier New';">检查双链表是否还有节点<br></span>public bool valid ( void )<br><br>//<span style="font-family:'Courier New';">指定</span>index<span style="font-family:'Courier New';">处节点是否存在<br></span>public bool offsetExists ( mixed $index )<br>//<span style="font-family:'Courier New';">获取指定</span>index<span style="font-family:'Courier New';">处节点值<br></span>public mixed offsetGet ( mixed $index )<br>//<span style="font-family:'Courier New';">设置指定</span>index<span style="font-family:'Courier New';">处值<br></span>public void offsetSet ( mixed $index , mixed $newval )<br>//<span style="font-family:'Courier New';">删除指定</span>index<span style="font-family:'Courier New';">处节点<br></span>public void offsetUnset ( mixed $index )<br><br>//<span style="font-family:'Courier New';">从双链表的尾部弹出元素<br></span>public mixed pop ( void )<br>//<span style="font-family:'Courier New';">添加元素到双链表的尾部<br></span>public void push ( mixed $value )<br><br>//<span style="font-family:'Courier New';">序列化存储<br></span>public string serialize ( void )<br>//<span style="font-family:'Courier New';">反序列化<br></span>public void unserialize ( string $serialized )<br><br>//<span style="font-family:'Courier New';">设置迭代模式<br></span>public void setIteratorMode ( int $mode )<br>//<span style="font-family:'Courier New';">获取迭代模式</span>SplDoublyLinkedList::IT_MODE_LIFO (Stack style) SplDoublyLinkedList::IT_MODE_FIFO (Queue style)<br>public int getIteratorMode ( void )<br><br>//<span style="font-family:'Courier New';">双链表的头部移除元素<br></span>public mixed shift ( void )<br>//<span style="font-family:'Courier New';">双链表的头部添加元素<br></span>public void unshift ( mixed $value )<br><br>}<br><br><span style="font-family:'Courier New';">使用起来也比较简单<br></span>$list = new SplDoublyLinkedList();<br>$list-&gt;push('a');<br>$list-&gt;push('b');<br>$list-&gt;push('c');<br>$list-&gt;push('d');<br><br>$list-&gt;unshift('top');<br>$list-&gt;shift();<br><br>$list-&gt;rewind();//rewind<span style="font-family:'Courier New';">操作用于把节点指针指向</span>Bottom<span style="font-family:'Courier New';">所在的节点<br></span>echo 'curren node:'.$list-&gt;current()."<span style="color:#93a1a1;">&lt;</span><span style="color:#268bd2;font-weight:bold;">br </span><span style="color:#93a1a1;">/&gt;</span>";//<span style="font-family:'Courier New';">获取当前节点<br></span><span style="font-family:'Courier New';"><br></span>$list-&gt;next();//<span style="font-family:'Courier New';">指针指向下一个节点<br></span>echo 'next node:'.$list-&gt;current()."<span style="color:#93a1a1;">&lt;</span><span style="color:#268bd2;font-weight:bold;">br </span><span style="color:#93a1a1;">/&gt;</span>";<br><br>$list-&gt;next();<br>$list-&gt;next();<br>$list-&gt;prev();//<span style="font-family:'Courier New';">指针指向上一个节点<br></span>echo 'next node:'.$list-&gt;current()."<span style="color:#93a1a1;">&lt;</span><span style="color:#268bd2;font-weight:bold;">br </span><span style="color:#93a1a1;">/&gt;</span>";<br><br>if($list-&gt;current())<br>echo 'current node is valid<span style="color:#93a1a1;">&lt;</span><span style="color:#268bd2;font-weight:bold;">br </span><span style="color:#93a1a1;">/&gt;</span>';<br>else<br>echo 'current node is invalid<span style="color:#93a1a1;">&lt;</span><span style="color:#268bd2;font-weight:bold;">br </span><span style="color:#93a1a1;">/&gt;</span>';<br><br><br>if($list-&gt;valid())//<span style="font-family:'Courier New';">如果当前节点是有效节点，</span>valid<span style="font-family:'Courier New';">返回</span>true<br>echo "valid list<span style="color:#93a1a1;">&lt;</span><span style="color:#268bd2;font-weight:bold;">br </span><span style="color:#93a1a1;">/&gt;</span>";<br>else<br>echo "invalid list <span style="color:#93a1a1;">&lt;</span><span style="color:#268bd2;font-weight:bold;">br </span><span style="color:#93a1a1;">/&gt;</span>";<br><br><br>var_dump(array(<br>'pop' =&gt; $list-&gt;pop(),<br>'count' =&gt; $list-&gt;count(),<br>'isEmpty' =&gt; $list-&gt;isEmpty(),<br>'bottom' =&gt; $list-&gt;bottom(),<br>'top' =&gt; $list-&gt;top()<br>));<br><br>$list-&gt;setIteratorMode(SplDoublyLinkedList::IT_MODE_FIFO);<br>var_dump($list-&gt;getIteratorMode());<br><br>for($list-&gt;rewind(); $list-&gt;valid(); $list-&gt;next()) {<br>echo $list-&gt;current().PHP_EOL;<br>}<br><br>var_dump($a = $list-&gt;serialize());<br>//print_r($list-&gt;unserialize($a));<br><br>$list-&gt;offsetSet(0,'new one');<br>$list-&gt;offsetUnset(0);<br>var_dump(array(<br>'offsetExists' =&gt; $list-&gt;offsetExists(4),<br>'offsetGet' =&gt; $list-&gt;offsetGet(0),<br><br>));<br>var_dump($list);<br><br>//<span style="font-family:'Courier New';">堆栈，先进后出<br></span>$stack = new SplStack();//<span style="font-family:'Courier New';">继承自</span>SplDoublyLinkedList<span style="font-family:'Courier New';">类<br></span><span style="font-family:'Courier New';"><br></span>$stack-&gt;push("a<span style="color:#93a1a1;">&lt;</span><span style="color:#268bd2;font-weight:bold;">br </span><span style="color:#93a1a1;">/&gt;</span>");<br>$stack-&gt;push("b<span style="color:#93a1a1;">&lt;</span><span style="color:#268bd2;font-weight:bold;">br </span><span style="color:#93a1a1;">/&gt;</span>");<br><br>echo $stack-&gt;pop();<br>echo $stack-&gt;pop();<br>echo $stack-&gt;offsetSet(0,'B');//<span style="font-family:'Courier New';">堆栈的</span>offset=0<span style="font-family:'Courier New';">是</span>Top<span style="font-family:'Courier New';">所在的位置，</span>offset=1<span style="font-family:'Courier New';">是</span>Top<span style="font-family:'Courier New';">位置节点靠近</span>bottom<span style="font-family:'Courier New';">位置的相邻节点，以此类推<br></span>$stack-&gt;rewind();//<span style="font-family:'Courier New';">双向链表的</span>rewind<span style="font-family:'Courier New';">和堆栈的</span>rewind<span style="font-family:'Courier New';">相反，堆栈的</span>rewind<span style="font-family:'Courier New';">使得当前指针指向</span>Top<span style="font-family:'Courier New';">所在的位置，而双向链表调用之后指向</span>bottom<span style="font-family:'Courier New';">所在位置<br></span>echo 'current:'.$stack-&gt;current().'<span style="color:#93a1a1;">&lt;</span><span style="color:#268bd2;font-weight:bold;">br </span><span style="color:#93a1a1;">/&gt;</span>';<br><br>$stack-&gt;next();//<span style="font-family:'Courier New';">堆栈的</span>next<span style="font-family:'Courier New';">操作使指针指向靠近</span>bottom<span style="font-family:'Courier New';">位置的下一个节点，而双向链表是靠近</span>top<span style="font-family:'Courier New';">的下一个节点<br></span>echo 'current:'.$stack-&gt;current().'<span style="color:#93a1a1;">&lt;</span><span style="color:#268bd2;font-weight:bold;">br </span><span style="color:#93a1a1;">/&gt;</span>';<br>echo '<span style="color:#93a1a1;">&lt;</span><span style="color:#268bd2;font-weight:bold;">br </span><span style="color:#93a1a1;">/&gt;&lt;</span><span style="color:#268bd2;font-weight:bold;">br </span><span style="color:#93a1a1;">/&gt;</span>';<br><br>//<span style="font-family:'Courier New';">队列，先进先出<br></span>$queue = new SplQueue();//<span style="font-family:'Courier New';">继承自</span>SplDoublyLinkedList<span style="font-family:'Courier New';">类<br></span><span style="font-family:'Courier New';"><br></span>$queue-&gt;enqueue("a<span style="color:#93a1a1;">&lt;</span><span style="color:#268bd2;font-weight:bold;">br </span><span style="color:#93a1a1;">/&gt;</span>");//<span style="font-family:'Courier New';">插入一个节点到队列里面的</span>Top<span style="font-family:'Courier New';">位置<br></span>$queue-&gt;enqueue("b<span style="color:#93a1a1;">&lt;</span><span style="color:#268bd2;font-weight:bold;">br </span><span style="color:#93a1a1;">/&gt;</span>");<br><br>$queue-&gt;offsetSet(0,'A');//<span style="font-family:'Courier New';">堆栈的</span>offset=0<span style="font-family:'Courier New';">是</span>Top<span style="font-family:'Courier New';">所在的位置，</span>offset=1<span style="font-family:'Courier New';">是</span>Top<span style="font-family:'Courier New';">位置节点靠近</span>bottom<span style="font-family:'Courier New';">位置的相邻节点，以此类推<br></span><span style="font-family:'Courier New';"><br></span>echo $queue-&gt;dequeue();<br>echo $queue-&gt;dequeue();<br><br>echo "<span style="color:#93a1a1;">&lt;</span><span style="color:#268bd2;font-weight:bold;">br </span><span style="color:#93a1a1;">/&gt;&lt;</span><span style="color:#268bd2;font-weight:bold;">br </span><span style="color:#93a1a1;">/&gt;</span>";<br><br><span style="font-family:'Courier New';">堆<br></span>SplHeap<br>    SplMaxHeap<br>    SplMinHeap<br><span style="font-family:'Courier New';">堆</span>(Heap)<span style="font-family:'Courier New';">就是为了实现优先队列而设计的一种数据结构，它是通过构造二叉堆</span>(<span style="font-family:'Courier New';">二叉树的一种</span>)<span style="font-family:'Courier New';">实现。根节点最大的堆叫做最大堆或大根堆（</span>SplMaxHeap<span style="font-family:'Courier New';">），根节点最小的堆叫做最小堆或小根堆（</span>SplMinHeap<span style="font-family:'Courier New';">）。二叉堆还常用于排序</span>(<span style="font-family:'Courier New';">堆排序</span>)<span style="font-family:'Courier New';">。<br></span>SplHeap<span style="font-family:'Courier New';">类摘要如下：<br></span>abstract SplHeap implements Iterator , Countable {<br><span style="font-family:'Courier New';">　　</span>/* <span style="font-family:'Courier New';">方法 </span>*/<br><span style="font-family:'Courier New';">　　</span>public __construct ( void )<br><span style="font-family:'Courier New';">　　</span>abstract protected int compare ( mixed $value1 , mixed $value2 )<br><span style="font-family:'Courier New';">　　</span>public int count ( void )<br><span style="font-family:'Courier New';">　　</span>public mixed current ( void )<br><span style="font-family:'Courier New';">　　</span>public mixed extract ( void )<br><span style="font-family:'Courier New';">　　</span>public void insert ( mixed $value )<br><span style="font-family:'Courier New';">　　</span>public bool isEmpty ( void )<br><span style="font-family:'Courier New';">　　</span>public mixed key ( void )<br><span style="font-family:'Courier New';">　　</span>public void next ( void )<br><span style="font-family:'Courier New';">　　</span>public void recoverFromCorruption ( void )<br><span style="font-family:'Courier New';">　　</span>public void rewind ( void )<br><span style="font-family:'Courier New';">　　</span>public mixed top ( void )<br><span style="font-family:'Courier New';">　　</span>public bool valid ( void )<br>}<br><span style="font-family:'Courier New';">显然它是一个抽象类，最大堆</span>(SplMaxHeap)<span style="font-family:'Courier New';">和最小堆</span>(SplMinHeap)<span style="font-family:'Courier New';">就是继承它实现的。最大堆和最小堆并没有额外的方法。<br></span>SplHeap<span style="font-family:'Courier New';">简单使用：<br></span>//<span style="font-family:'Courier New';">堆<br></span>class MySplHeap extends SplHeap{<br>//compare()<span style="font-family:'Courier New';">方法用来比较两个元素的大小，绝对他们在堆中的位置<br></span>public function compare( $value1, $value2 ) {<br>return ( $value1 - $value2 );<br>}<br>}<br><br>$obj = new MySplHeap();<br><br>$obj-&gt;insert(0);<br>$obj-&gt;insert(1);<br>$obj-&gt;insert(2);<br>$obj-&gt;insert(3);<br>$obj-&gt;insert(4);<br><br>echo $obj-&gt;top();//4<br>echo $obj-&gt;count();//5<br><br>foreach ($obj as $item) {<br>echo $item."<span style="color:#93a1a1;">&lt;</span><span style="color:#268bd2;font-weight:bold;">br </span><span style="color:#93a1a1;">/&gt;</span>";<br>}<br><br><span style="font-family:'Courier New';">队列<br></span>SplPriorityQueue<br><span style="font-family:'Courier New';">优先队列也是非常实用的一种数据结构，可以通过加权对值进行排序，由于排序在</span>php<span style="font-family:'Courier New';">内部实现，业务代码中将精简不少而且更高效。通过</span>SplPriorityQueue::setExtractFlags(int  $flag)<span style="font-family:'Courier New';">设置提取方式可以提取数据（等同最大堆）、优先级、和两者都提取的方式。<br></span>SplPriorityQueue<span style="font-family:'Courier New';">类摘要如下：<br></span>SplPriorityQueue implements Iterator , Countable {<br><span style="font-family:'Courier New';">　　</span>/* <span style="font-family:'Courier New';">方法 </span>*/<br><span style="font-family:'Courier New';">　　</span>public __construct ( void )<br><span style="font-family:'Courier New';">　　</span>public int compare ( mixed $priority1 , mixed $priority2 )<br><span style="font-family:'Courier New';">　　</span>public int count ( void )<br><span style="font-family:'Courier New';">　　</span>public mixed current ( void )<br><span style="font-family:'Courier New';">　　</span>public mixed extract ( void )<br><span style="font-family:'Courier New';">　　</span>public void insert ( mixed $value , mixed $priority )<br><span style="font-family:'Courier New';">　　</span>public bool isEmpty ( void )<br><span style="font-family:'Courier New';">　　</span>public mixed key ( void )<br><span style="font-family:'Courier New';">　　</span>public void next ( void )<br><span style="font-family:'Courier New';">　　</span>public void recoverFromCorruption ( void )<br><span style="font-family:'Courier New';">　　</span>public void rewind ( void )<br><span style="font-family:'Courier New';">　　</span>public void setExtractFlags ( int $flags )<br><span style="font-family:'Courier New';">　　</span>public mixed top ( void )<br><span style="font-family:'Courier New';">　　</span>public bool valid ( void )<br>}<br><span style="font-family:'Courier New';">简单使用：<br></span>$pq = new SplPriorityQueue();<br>$pq-&gt;insert('a', 10);<br>$pq-&gt;insert('b', 1);<br>$pq-&gt;insert('c', 8);<br><br>echo $pq-&gt;count() .PHP_EOL; //3<br>echo $pq-&gt;current() . PHP_EOL; //a<br><br>/**<br>* <span style="font-family:'Courier New';">设置元素出队模式<br></span>* SplPriorityQueue::EXTR_DATA <span style="font-family:'Courier New';">仅提取值<br></span>* SplPriorityQueue::EXTR_PRIORITY <span style="font-family:'Courier New';">仅提取优先级<br></span>* SplPriorityQueue::EXTR_BOTH <span style="font-family:'Courier New';">提取数组包含值和优先级<br></span>*/<br>$pq-&gt;setExtractFlags(SplPriorityQueue::EXTR_DATA);<br><br>while($pq-&gt;valid()) {<br>print_r($pq-&gt;current());  //a  c  b<br>$pq-&gt;next();<br>}<br><br><span style="font-family:'Courier New';">阵列<br></span>SplFixedArray<br>SplFixedArray<span style="font-family:'Courier New';">主要是处理数组相关的主要功能，与普通</span>php array<span style="font-family:'Courier New';">不同的是，它是固定长度的，且以数字为键名的数组，优势就是比普通的数组处理更快。通常情况下</span>SplFixedArray<span style="font-family:'Courier New';">要比</span>php array<span style="font-family:'Courier New';">快上</span>20%~30%<span style="font-family:'Courier New';">，所以如果你是处理巨大数量的固定长度数组，还是强烈建议使用。<br></span>SplFixedArray<span style="font-family:'Courier New';">类摘要如下：<br></span>SplFixedArray implements Iterator , ArrayAccess , Countable {<br><span style="font-family:'Courier New';">　　</span>/* <span style="font-family:'Courier New';">方法 </span>*/<br><span style="font-family:'Courier New';">　　</span>public __construct ([ int $size = 0 ] )<br><span style="font-family:'Courier New';">　　</span>public int count ( void )<br><span style="font-family:'Courier New';">　　</span>public mixed current ( void )<br><span style="font-family:'Courier New';">　　</span>public static SplFixedArray fromArray ( array $array [, bool $save_indexes = true ] )<br><span style="font-family:'Courier New';">　　</span>public int getSize ( void )<br><span style="font-family:'Courier New';">　　</span>public int key ( void )<br><span style="font-family:'Courier New';">　　</span>public void next ( void )<br><span style="font-family:'Courier New';">　　</span>public bool offsetExists ( int $index )<br><span style="font-family:'Courier New';">　　</span>public mixed offsetGet ( int $index )<br><span style="font-family:'Courier New';">　　</span>public void offsetSet ( int $index , mixed $newval )<br><span style="font-family:'Courier New';">　　</span>public void offsetUnset ( int $index )<br><span style="font-family:'Courier New';">　　</span>public void rewind ( void )<br><span style="font-family:'Courier New';">　　</span>public int setSize ( int $size )<br><span style="font-family:'Courier New';">　　</span>public array toArray ( void )<br><span style="font-family:'Courier New';">　　</span>public bool valid ( void )<br><span style="font-family:'Courier New';">　　</span>public void __wakeup ( void )<br>}<br><span style="font-family:'Courier New';">简单使用：<br></span>$arr = new SplFixedArray(4);<br>$arr[0] = 'php';<br>$arr[1] = 1;<br>$arr[3] = 'python';<br><br>//<span style="font-family:'Courier New';">遍历， </span>$arr[2] <span style="font-family:'Courier New';">为</span>null<br>foreach($arr as $v) {<br>echo $v . PHP_EOL;<br>}<br><br>//<span style="font-family:'Courier New';">获取数组长度<br></span>echo $arr-&gt;getSize(); //4<br><br>//<span style="font-family:'Courier New';">增加数组长度<br></span>$arr-&gt;setSize(5);<br>$arr[4] = 'new one';<br><br>//<span style="font-family:'Courier New';">捕获异常<br></span>try{<br>echo $arr[10];<br>} catch (RuntimeException $e) {<br>echo $e-&gt;getMessage();<br>}<br><br><span style="font-family:'Courier New';">映射<br></span>SplObjectStorage<br><span style="font-family:'Courier New';">用来存储一组对象的，特别是当你需要唯一标识对象的时候。<br></span>PHP SPL SplObjectStorage<span style="font-family:'Courier New';">类实现了</span>Countable,Iterator,Serializable,ArrayAccess<span style="font-family:'Courier New';">四个接口。可实现统计、迭代、序列化、数组式访问等功能。<br></span>SplObjectStorage<span style="font-family:'Courier New';">类摘要如下：<br></span>SplObjectStorage implements Countable , Iterator , Serializable , ArrayAccess {<br><span style="font-family:'Courier New';">　　</span>/* <span style="font-family:'Courier New';">方法 </span>*/<br><span style="font-family:'Courier New';">　　</span>public void addAll ( SplObjectStorage $storage )<br><span style="font-family:'Courier New';">　　</span>public void attach ( object $object [, mixed $data = NULL ] )<br><span style="font-family:'Courier New';">　　</span>public bool contains ( object $object )<br><span style="font-family:'Courier New';">　　</span>public int count ( void )<br><span style="font-family:'Courier New';">　　</span>public object current ( void )<br><span style="font-family:'Courier New';">　　</span>public void detach ( object $object )<br><span style="font-family:'Courier New';">　　</span>public string getHash ( object $object )<br><span style="font-family:'Courier New';">　　</span>public mixed getInfo ( void )<br><span style="font-family:'Courier New';">　　</span>public int key ( void )<br><span style="font-family:'Courier New';">　　</span>public void next ( void )<br><span style="font-family:'Courier New';">　　</span>public bool offsetExists ( object $object )<br><span style="font-family:'Courier New';">　　</span>public mixed offsetGet ( object $object )<br><span style="font-family:'Courier New';">　　</span>public void offsetSet ( object $object [, mixed $data = NULL ] )<br><span style="font-family:'Courier New';">　　</span>public void offsetUnset ( object $object )<br><span style="font-family:'Courier New';">　　</span>public void removeAll ( SplObjectStorage $storage )<br><span style="font-family:'Courier New';">　　</span>public void removeAllExcept ( SplObjectStorage $storage )<br><span style="font-family:'Courier New';">　　</span>public void rewind ( void )<br><span style="font-family:'Courier New';">　　</span>public string serialize ( void )<br><span style="font-family:'Courier New';">　　</span>public void setInfo ( mixed $data )<br><span style="font-family:'Courier New';">　　</span>public void unserialize ( string $serialized )<br><span style="font-family:'Courier New';">　　</span>public bool valid ( void )<br>}<br><span style="font-family:'Courier New';">简单使用：<br></span>class A {<br>public $i;<br>public function __construct($i) {<br>$this-&gt;i = $i;<br>}<br>}<br><br>$a1 = new A(1);<br>$a2 = new A(2);<br>$a3 = new A(3);<br>$a4 = new A(4);<br><br>$container = new SplObjectStorage();<br><br>//SplObjectStorage::attach <span style="font-family:'Courier New';">添加对象到</span>Storage<span style="font-family:'Courier New';">中<br></span>$container-&gt;attach($a1);<br>$container-&gt;attach($a2);<br>$container-&gt;attach($a3);<br><br>//SplObjectStorage::detach <span style="font-family:'Courier New';">将对象从</span>Storage<span style="font-family:'Courier New';">中移除<br></span>$container-&gt;detach($a2);<br><br>//SplObjectStorage::contains<span style="font-family:'Courier New';">用于检查对象是否存在</span>Storage<span style="font-family:'Courier New';">中<br></span>var_dump($container-&gt;contains($a1)); //true<br>var_dump($container-&gt;contains($a4)); //false<br><br>//<span style="font-family:'Courier New';">遍历<br></span>$container-&gt;rewind();<br>while($container-&gt;valid()) {<br>var_dump($container-&gt;current());<br>$container-&gt;next();<br>}<br><br></pre>