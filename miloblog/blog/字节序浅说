  
	  
	<pre style="background-color:#fdf6e3;color:#586e75;font-family:'Courier New';font-size:13.5pt;"><b>什么是字节序</b><br>在不同的计算机体系结构中，对于数据<span style="font-family:'Source Code Pro';">(</span>比特、字节、字<span style="font-family:'Source Code Pro';">)</span>等的存储和传输机制有所不同，因而引发了计算机领域中一个潜在但是又很重要的问题，即通信双 方交流的信息单元应该以什么样的顺序进行传送。如果达不成一致的规则，计算机的通信与存储将会无法进行。目前在各种体系的计算机中通常采用的字节存储机制 主要有两种：大端<span style="font-family:'Source Code Pro';">(Big-endian)</span>和小端<span style="font-family:'Source Code Pro';">(Little-endian)</span>。这里所说的大端和小端即是字节序。<br><b>大端模式</b><br>所谓的大端模式（<span style="font-family:'Source Code Pro';">Big-endian</span>），是指数据的高字节，保存在内存的低地址中，而数据的低字节，保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；<br><b>小端模式</b><br>所谓的小端模式（<span style="font-family:'Source Code Pro';">Little-endian</span>），是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。<br><b>为什么会有大小端模式之分呢？</b>这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 <span style="font-family:'Source Code Pro';">8bit</span>。但是在<span style="font-family:'Source Code Pro';">C</span>语言中除了<span style="font-family:'Source Code Pro';">8bit</span>的<span style="font-family:'Source Code Pro';">char</span>之外，还有<span style="font-family:'Source Code Pro';">16bit</span>的<span style="font-family:'Source Code Pro';">short</span>型，<span style="font-family:'Source Code Pro';">32bit</span>的<span style="font-family:'Source Code Pro';">long</span>型（要看具体的编译器），另外，对于位数大于 <span style="font-family:'Source Code Pro';">8</span>位的处理器，例如<span style="font-family:'Source Code Pro';">16</span>位或者<span style="font-family:'Source Code Pro';">32</span>位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个<span style="font-family:'Source Code Pro';">16bit</span>的<span style="font-family:'Source Code Pro';">short</span>型<span style="font-family:'Source Code Pro';">x</span>，在内存中的地址为<span style="font-family:'Source Code Pro';">0x0010</span>，<span style="font-family:'Source Code Pro';">x</span>的值为<span style="font-family:'Source Code Pro';">0x1122</span>，那么<span style="font-family:'Source Code Pro';">0x11</span>为高字节，<span style="font-family:'Source Code Pro';">0x22</span>为低字节。对于 大端模式，就将<span style="font-family:'Source Code Pro';">0x11</span>放在低地址中，即<span style="font-family:'Source Code Pro';">0x0010</span>中，<span style="font-family:'Source Code Pro';">0x22</span>放在高地址中，即<span style="font-family:'Source Code Pro';">0x0011</span>中。小端模式，刚好相反。我们常用的<span style="font-family:'Source Code Pro';">X86</span>结构是小端模式，而<span style="font-family:'Source Code Pro';">KEIL C51</span>则为大端模式。很多的<span style="font-family:'Source Code Pro';">ARM</span>，<span style="font-family:'Source Code Pro';">DSP</span>都为小端模式。有些<span style="font-family:'Source Code Pro';">ARM</span>处理器还可以随时在程序中<span style="font-family:'Source Code Pro';">(</span>在<span style="font-family:'Source Code Pro';">ARM Cortex </span>系列使用<span style="font-family:'Source Code Pro';">REV</span>、<span style="font-family:'Source Code Pro';">REV16</span>、<span style="font-family:'Source Code Pro';">REVSH</span>指令  <span style="font-family:'Source Code Pro';">)</span>进行大小端的切换。<br><b>网络字节序：</b>网络字节序是指大端序。<span style="font-family:'Source Code Pro';">TCP/IP</span>都是采用网络字节序的方式。<b>主机字节序：</b>主机字节序代表本机的字节序。一般是小端序，但也有一些是大端序。<br>字节序只针对于多字节类型的数据。比如对于4个字节的<span style="font-family:'Source Code Pro';">int</span>类型整数<span style="font-family:'Source Code Pro';">0x12345678</span>，它占有<span style="font-family:'Source Code Pro';">4</span>个字节的存储空间，存储方式有大端<span style="font-family:'Source Code Pro';">(0x12, 0x34, 0x56, 0x78)</span>和小端<span style="font-family:'Source Code Pro';">(0x78, 0x56, 0x34, 0x12)</span>两种。可以看到，在大端或小端的存储方式中，是以字节为单位的。所以对于单字节类型的数据，不存在字节序这个说法。<br></pre>