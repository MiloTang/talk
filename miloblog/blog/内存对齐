  
	<pre style="background-color:#fdf6e3;color:#586e75;font-family:'Courier New';font-size:13.5pt;">typedef struct Student<br>{<br>int  age;<br>char sex[1];<br>int  height;<br>}Student;<br><span style="font-family:'Courier New';">以上这个结构体占用内存多少空间呢？也许你会说，这个简单，计算每个类型的大小，将它们相加就行了，以</span>32<span style="font-family:'Courier New';">为平台为例，</span>int<span style="font-family:'Courier New';">类型占</span>4<span style="font-family:'Courier New';">字节，</span>char<span style="font-family:'Courier New';">占用</span>1<span style="font-family:'Courier New';">字节，所以：</span>4 + 1 + 4 = 9<span style="font-family:'Courier New';">，那么这个结构体一共占用</span>9<span style="font-family:'Courier New';">字节空间。好吧，那么我们就用实践来证明是否正确，我们用</span>sizeof<span style="font-family:'Courier New';">运算符来求出这个结构体占用内存空间大小，</span>sizeof(Student)<span style="font-family:'Courier New';">，出乎意料的是，结果居然为</span>12,这就更内存对其有关系了。<br><b>内存地址对齐</b>，是一种在计算机内存中排列数据（表现为变量的地址）、访问数据（表现为<span style="font-family:'Source Code Pro';">CPU</span>读取数据）的一种方式，包含了两种相互独立又相互关联的部分：基本数据对齐和结构体数据对齐 。<br>在现代计算机体系中，每次读写内存中数据，都是按字（<span style="font-family:'Source Code Pro';">word</span>，<span style="font-family:'Source Code Pro';">4</span>个字节，对于<span style="font-family:'Source Code Pro';">X86</span>架构，系统是<span style="font-family:'Source Code Pro';">32</span>位，数据总线和地址总线的宽度都是<span style="font-family:'Source Code Pro';">32</span>位，所以最大的寻址空间为<span style="font-family:'Source Code Pro';">232 = 4GB</span>（也 许有人会问，我的<span style="font-family:'Source Code Pro';">32</span>位<span style="font-family:'Source Code Pro';">XP</span>用不了<span style="font-family:'Source Code Pro';">4GB</span>内存，关于这个不在本篇博文讨论范围），按<span style="font-family:'Source Code Pro';">A[31,30…2,1,0]</span>这样排列，但是请注意为了<span style="font-family:'Source Code Pro';">CPU</span>每次读写 <span style="font-family:'Source Code Pro';">4</span>个字节寻址，<span style="font-family:'Source Code Pro';">A[0]</span>和<span style="font-family:'Source Code Pro';">A[1]</span>两位是不参与寻址计算的。）为一个块（<span style="font-family:'Source Code Pro';">chunks</span>）来操作（而对于<span style="font-family:'Source Code Pro';">X64</span>则是<span style="font-family:'Source Code Pro';">8</span>个字节为一个快）。注意，这里说的 <span style="font-family:'Source Code Pro';">CPU</span>每次读取的规则，并不是变量在内存中地址对齐规则。既然是这样的，如果变量在内存中存储的时候也按照这样的对齐规则，就可以加快<span style="font-family:'Source Code Pro';">CPU</span>读写内存的速 度，当然也就提高了整个程序的性能，并且性能提升是客观，虽然当今的<span style="font-family:'Source Code Pro';">CPU</span>的处理数据速度<span style="font-family:'Source Code Pro';">(</span>是指逻辑运算等<span style="font-family:'Source Code Pro';">,</span>不包括取址<span style="font-family:'Source Code Pro';">)</span>远比内存访问的速度快，程序的执 行速度的瓶颈往往不是<span style="font-family:'Source Code Pro';">CPU</span>的处理速度不够，而是内存访问的延迟，虽然当今<span style="font-family:'Source Code Pro';">CPU</span>中加入了高速缓存用来掩盖内存访问的延迟，但是如果高密集的内存访问，一 种延迟是无可避免的，内存地址对齐会给程序带来了很大的性能提升。<br><br>内存地址对齐是计算机语言自动进行的，也即是编译器所做的工作。但这不意味着我们程序员不需要做任何事情，因为如果我们能够遵循某些规则，可以让编译器做得更好，毕竟编译器不是万能的。<br><br>为了更好理解上面的意思，这里给出一个示例。在<span style="font-family:'Source Code Pro';">32</span>位系统中，假如一个<span style="font-family:'Source Code Pro';">int</span>变量在内存中的地址是<span style="font-family:'Source Code Pro';">0x00ff42c3,</span>因为<span style="font-family:'Source Code Pro';">int</span>是占用<span style="font-family:'Source Code Pro';">4</span>个字节，所以它的尾地址应该是<span style="font-family:'Source Code Pro';">0x00ff42c6</span>，这个时候<span style="font-family:'Source Code Pro';">CPU</span>为了读取这个<span style="font-family:'Source Code Pro';">int</span>变量的值，就需要先后读取两个<span style="font-family:'Source Code Pro';">word</span>大小的块，分别是<span style="font-family:'Source Code Pro';">0x00ff42c0~0x00ff42c3</span>和<span style="font-family:'Source Code Pro';">0x00ff42c4~0x00ff42c7</span>，然后通过移位等一系列的操作来得到，在这个计算的过程中还有可能引起一些总线数据错误的。但是如果编译器对变量地址进行了对齐，比如放在<span style="font-family:'Source Code Pro';">0x00ff42c0</span>，<span style="font-family:'Source Code Pro';">CPU</span>就只需要一次就可以读取到，这样的话就加快读取效率。<br><br><span style="font-family:'Source Code Pro';">1</span>、基本数据对齐<br>在<span style="font-family:'Source Code Pro';">X86</span>，<span style="font-family:'Source Code Pro';">32</span>位系统下基于<span style="font-family:'Source Code Pro';">Microsoft</span>、<span style="font-family:'Source Code Pro';">Borland</span>和<span style="font-family:'Source Code Pro';">GNU</span>的编译器，有如下数据对齐规则：<br><span style="font-family:'Source Code Pro';">a</span>、一个<span style="font-family:'Source Code Pro';">char</span>（占用<span style="font-family:'Source Code Pro';">1-byte</span>）变量以<span style="font-family:'Source Code Pro';">1-byte</span>对齐。<br><span style="font-family:'Source Code Pro';">b</span>、一个<span style="font-family:'Source Code Pro';">short</span>（占用<span style="font-family:'Source Code Pro';">2-byte</span>）变量以<span style="font-family:'Source Code Pro';">2-byte</span>对齐。<br><span style="font-family:'Source Code Pro';">c</span>、一个<span style="font-family:'Source Code Pro';">int</span>（占用<span style="font-family:'Source Code Pro';">4-byte</span>）变量以<span style="font-family:'Source Code Pro';">4-byte</span>对齐。<br><span style="font-family:'Source Code Pro';">d</span>、一个<span style="font-family:'Source Code Pro';">long</span>（占用<span style="font-family:'Source Code Pro';">4-byte</span>）变量以<span style="font-family:'Source Code Pro';">4-byte</span>对齐。<br><span style="font-family:'Source Code Pro';">e</span>、一个<span style="font-family:'Source Code Pro';">float</span>（占用<span style="font-family:'Source Code Pro';">4-byte</span>）变量以<span style="font-family:'Source Code Pro';">4-byte</span>对齐。<br><span style="font-family:'Source Code Pro';">f</span>、一个<span style="font-family:'Source Code Pro';">double</span>（占用<span style="font-family:'Source Code Pro';">8-byte</span>）变量以<span style="font-family:'Source Code Pro';">8-byte</span>对齐。<br><span style="font-family:'Source Code Pro';">g</span>、一个<span style="font-family:'Source Code Pro';">long double</span>（占用<span style="font-family:'Source Code Pro';">12-byte</span>）变量以<span style="font-family:'Source Code Pro';">4-byte</span>对齐。<br><span style="font-family:'Source Code Pro';">h</span>、任何<span style="font-family:'Source Code Pro';">pointer</span>（占用<span style="font-family:'Source Code Pro';">4-byte</span>）变量以<span style="font-family:'Source Code Pro';">4-byte</span>对齐。<br><br>而在<span style="font-family:'Source Code Pro';">64</span>位系统下，与上面规则对比有如下不同：<br><span style="font-family:'Source Code Pro';">a</span>、一个<span style="font-family:'Source Code Pro';">long</span>（占用<span style="font-family:'Source Code Pro';">8-byte</span>）变量以<span style="font-family:'Source Code Pro';">8-byte</span>对齐。<br><span style="font-family:'Source Code Pro';">b</span>、一个<span style="font-family:'Source Code Pro';">double</span>（占用<span style="font-family:'Source Code Pro';">8-byte</span>）变量以<span style="font-family:'Source Code Pro';">8-byte</span>对齐。<br><span style="font-family:'Source Code Pro';">c</span>、一个<span style="font-family:'Source Code Pro';">long double</span>（占用<span style="font-family:'Source Code Pro';">16-byte</span>）变量以<span style="font-family:'Source Code Pro';">16-byte</span>对齐。<br><span style="font-family:'Source Code Pro';">d</span>、任何<span style="font-family:'Source Code Pro';">pointer</span>（占用<span style="font-family:'Source Code Pro';">8-byte</span>）变量以<span style="font-family:'Source Code Pro';">8-byte</span>对齐。<br><br><span style="font-family:'Source Code Pro';">2</span>、结构体数据对齐<br>结构体数据对齐，是指结构体内的各个数据对齐。在结构体中的第一个成员的首地址等于整个结构体的变量的首地址，而后的成员的地址随着它声明的顺序和实际占用的字节数递增。为了总的结构体大小对齐，会在结构体中插入一些没有实际意思的字符来填充（<span style="font-family:'Source Code Pro';">padding</span>）结构体。<br><br>在结构体中，成员数据对齐满足以下规则：<br><span style="font-family:'Source Code Pro';">a</span>、结构体中的第一个成员的首地址也即是结构体变量的首地址。<br><span style="font-family:'Source Code Pro';">b</span>、结构体中的每一个成员的首地址相对于结构体的首地址的偏移量（<span style="font-family:'Source Code Pro';">offset</span>）是该成员数据类型大小的整数倍。<br><span style="font-family:'Source Code Pro';">c</span>、结构体的总大小是对齐模数（对齐模数等于<span style="font-family:'Source Code Pro';">#pragma pack(n)</span>所指定的<span style="font-family:'Source Code Pro';">n</span>与结构体中最大数据类型的成员大小的最小值）的整数倍。<br></pre>